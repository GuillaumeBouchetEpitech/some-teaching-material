
# C++ pimpl

or just "C++ **P**ointer to **IMPL**ementation"

## what is it?

## why is it useful?

## Practical example: "small-project"

### Folder hierarchy

```bash
src/
├── abstract-part
│   ├── internals
│   │   ├── MyImplClass.cpp
│   │   ├── MyImplClass.hpp
│   │   ├── TraceLogger.cpp
│   │   └── TraceLogger.hpp
│   ├── MyAbstractClass.cpp
│   └── MyAbstractClass.hpp
└── main.cpp
```

**Note:** We're skipping any and all explanations  about the `TraceLogger.hpp/cpp` files

### MyAbstractClass.hpp
```c++
// ./small-project/src/abstract-part/MyAbstractClass.hpp

#pragma once

#include <memory> // -> std::shared_ptr/unique_ptr

class MyAbstractClass
{
public:
  MyAbstractClass() = default;

  // the destructor MUST be virtual
  // -> if not done, the destructor of the "child class" is not called...
  virtual ~MyAbstractClass() = default;

  // disallow copy/move constructor (this is done...  ...just because)
  MyAbstractClass(const MyAbstractClass&) = delete;
  MyAbstractClass(MyAbstractClass&&) = delete;

  // disallow assignment operator (this is done...  ...just because)
  MyAbstractClass& operator=(const MyAbstractClass&) = delete;
  MyAbstractClass& operator=(MyAbstractClass&&) = delete;

public:
  // here we have a "virtual pure method"
  virtual void myMethod() = 0;

public:
  // static method that instantiate the implementation behind the abstract class
  static std::shared_ptr<MyAbstractClass> createAsShared();
  static std::unique_ptr<MyAbstractClass> createAsUnique();

};
```

### MyAbstractClass.cpp

```c++
// ./small-project/src/abstract-part/MyAbstractClass.cpp

#include "MyAbstractClass.hpp"

#include "./internals/MyImplClass.hpp"

std::shared_ptr<MyAbstractClass> MyAbstractClass::createAsShared()
{
  // expose MyAbstractClass, while under the hood it's MyImplClass
  return std::make_shared<MyImplClass>();
}

std::unique_ptr<MyAbstractClass> MyAbstractClass::createAsUnique()
{
  // expose MyAbstractClass, while under the hood it's MyImplClass
  return std::make_unique<MyImplClass>();
}
```

![./small-project/src/abstract-part/MyAbstractClass.hpp](./small-project/src/abstract-part/MyAbstractClass.hpp)


### MyImplClass.hpp

```c++
// ./small-project/src/abstract-part/internals/MyImplClass.hpp

#pragma once

#include "../MyAbstractClass.hpp"

#include <memory> // -> std::shared_ptr

class MyImplClass : public MyAbstractClass
{
public:
  MyImplClass();

  // avoid the "virtual" keyword in a child class if the parent already made it virtual
  ~MyImplClass();

public:
  // avoid the "virtual" keyword in a child class if the parent already made it virtual
  // the override keyword is mostly so that the compiler can check for errors
  void myMethod() override;
};
```

### MyImplClass.cpp

```c++
// ./small-project/src/abstract-part/internals/MyImplClass.cpp

#include "MyImplClass.hpp"

#include "./TraceLogger.hpp"

#include <iostream>

//
// here the implementation is very simple
// the main objective of using pimpl should be to separate any source code that
// is "weighting heavily on the compile time".
//
// Advisable usecases usually include:
// -> large (and slow to compile) third parties (ex: boost::asio templated logic)
// -> any justifiable "separation of concern" (implementation being unreachable)
// -> etc.
//

MyImplClass::MyImplClass()
{
  D_MYLOG("MyImplClass::ctor()");
}

MyImplClass::~MyImplClass()
{
  D_MYLOG("MyImplClass::dtor()");
}

void MyImplClass::myMethod()
{
  D_MYLOG("MyImplClass::myMethod()");
}

```
